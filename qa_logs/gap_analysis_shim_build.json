{
  "meta": {
    "generated_by": "automated-gap-analyzer",
    "reviewed_by": "manual-review-2025-10-23",
    "date": "2025-10-23",
    "repo": "afs",
    "branch": "master",
    "spec_folder": "Design/shim_build",
    "source_folder": "src",
    "qa_logs_folder": "qa_logs",
    "last_update": "Telemetry run capsule, UX flow card, and UX backlog scaffold specs checked against implementation - updated gap analysis with accurate status (2025-10-23). Telemetry capsule partial-improved with directory structure and Parquet writing but missing DuckDB consolidation and schema version 3. UX flow card partial-1of2 with stability card but missing math card and data contract. UX scaffold partial-improved with HTML framework but missing unified update function."
  },
  "summary": "Updated gap analysis following systematic checking of telemetry run capsule, UX flow card, and UX backlog scaffold specs against actual implementation (2025-10-23). Telemetry run capsule partial-improved with directory structure, Parquet writing, and atomic modes but missing DuckDB consolidation, schema version bump to 3, and core field computation. UX flow card partial-1of2 with stability card and anime.js animations but missing math card, data contract, and real telemetry integration. UX backlog scaffold partial-improved with HTML framework and animations but missing unified updateTelemetry function and complete data contract. Readiness checklist remains partial-4of16 with basic telemetry/checkpointing but 12 major gaps in production readiness. Each entry lists spec requirement, implementation status, files/locations, gaps, priority, and recommended next steps. Analysis cross-verified against Design/shim_build specs, src/ implementation, and qa_logs/ build records.",
  "items": [
    {
      "id": "primitives_api",
      "spec": "Core runtime primitives: F_Dis, F_Proj, F_Multi, F_Con, manifold adapters, operator interface",
      "status": "implemented-complete",
      "implemented_in": [
        "src/computable_flows_shim/runtime/primitives.py",
        "src/computable_flows_shim/runtime/engine.py",
        "src/computable_flows_shim/runtime/manifolds.py",
        "tests/test_manifold_adapters.py"
      ],
      "notes": [
        "All 5 core primitives implemented: F_Dis (dissipative), F_Proj (proximal), F_Multi (multiscale), F_Con (symplectic), F_Ann (stochastic).",
        "F_Dis implemented with full Riemannian manifold support using manifold adapters.",
        "F_Proj delegates to compiled g_prox functions.",
        "F_Multi uses TransformProtocol with jaxwt integration.",
        "F_Con implements symplectic Leapfrog integrator for Hamiltonian dynamics.",
        "Manifold adapters fully implemented: Euclidean, Sphere, Stiefel, PositiveDefinite with tangent projections and retractions.",
        "All primitives are JAX-jittable and follow mathematical definitions from design spec."
      ],
      "gaps": [
        "Operator interface (Op class) not implemented - design requires Op protocol with __call__, T(), lipschitz_hint().",
        "Extension points (registries, decorators) partially implemented - basic registries exist but decorators missing.",
        "Telemetry integration hooks present but not fully wired to Flight Recorder."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "Primitives are Functional Core: pure mathematical operations with zero side effects.",
        "Manifold adapters belong in Functional Core as pure geometric transformations.",
        "Runtime engine contains Imperative Shell elements (logging, telemetry) but primitives themselves are pure."
      ],
      "tdd_notes": [
        "Primitives built with TDD: comprehensive contract tests verify mathematical properties and JIT compatibility.",
        "Manifold adapters tested with geometric invariants (retraction preserves manifold, tangent projection correct).",
        "Operator interface requires TDD: write failing tests for Op protocol compliance."
      ],
      "recommended_next_steps": [
        "Implement Op class protocol as specified in design (02_primitives_operator_api.md).",
        "Add registry decorators for ops and manifolds.",
        "Complete telemetry integration with Flight Recorder hooks."
      ]
    },
    {
      "id": "atoms_library",
      "spec": "60-atom library (quadratic, tikhonov, l1, wavelet_l1, tv, etc.) with prox, energy, gradient, certificate contributions",
      "status": "partial-5of60",
      "implemented_in": [
        "src/computable_flows_shim/atoms/library.py",
        "src/computable_flows_shim/atoms/base.py",
        "src/computable_flows_shim/atoms/registry.py",
        "src/computable_flows_shim/atoms/quadratic/",
        "src/computable_flows_shim/atoms/tikhonov/",
        "src/computable_flows_shim/atoms/l1/",
        "src/computable_flows_shim/atoms/wavelet_l1/",
        "src/computable_flows_shim/atoms/tv/",
        "tests/test_atoms.py",
        "qa_logs/20251020_atoms_library_implementation.md",
        "qa_logs/20251023_atoms_library_modularization.md"
      ],
      "notes": [
        "Only 5 of 60 required atoms implemented (~8% complete): quadratic, tikhonov, l1, wavelet_l1, tv.",
        "Registry system implemented with register_atom/get_atom_class for dynamic discovery.",
        "Abstract Atom base class with proper interface contracts.",
        "All implemented atoms expose certificate contribution stubs (lipschitz, eta_dd_contribution, gamma_contribution).",
        "Individual test files per atom with comprehensive contract tests.",
        "36 tests passing across the 5 implemented atom implementations."
      ],
      "gaps": [
        "55 atoms missing implementation (design requires 60 total atoms).",
        "Per-atom cost models and sparsity-band metadata (for FDA) are lightweight/missing.",
        "W-space prox plumbing (atoms that act in W-space) not registered/handled specially."
      ],
      "priority": "high",
      "design_pattern_notes": [
        "Atoms are Functional Core: pure mathematical functions (energy, gradient, prox) with zero side effects.",
        "Registry and factory are Imperative Shell: handle atom discovery and instantiation."
      ],
      "tdd_notes": [
        "Atoms library built with strict TDD: each atom has comprehensive contract tests verifying mathematical properties.",
        "Test classes named 'Test[Atom]Contract' enforce preconditions, postconditions, and invariants.",
        "Missing atoms (TV, Wavelet L1) require TDD: write failing contract tests first, then implement pure mathematical functions."
      ],
      "recommended_next_steps": [
        "Implement remaining 55 atoms following TDD: write failing contract tests first, then implement pure mathematical functions.",
        "Migrate energy compiler from legacy atoms.library import to new registry system.",
        "Add per-atom cost models and sparsity-band metadata fields.",
        "Implement W-space prox special handling in registry/factory."
      ]
    },
    {
      "id": "energy_compiler",
      "spec": "Compile Python DSL EnergySpec -> CompiledEnergy {f_value, f_grad, g_prox, W, L_apply}, unit normalization, lens selection",
      "status": "basic-implemented",
      "implemented_in": [
        "src/computable_flows_shim/energy/compile.py",
        "src/computable_flows_shim/energy/specs.py",
        "tests/test_energy_compiler.py",
        "tests/test_w_space_compiler.py",
        "qa_logs/20251020_energy_compiler_implementation.md",
        "qa_logs/20251022_w_space_aware_compiler.md"
      ],
      "notes": [
        "Compiler produces jitted f_value, f_grad, g_prox, g_prox_in_W, and L_apply operator.",
        "EnergySpec implemented as Python DSL dataclasses (no YAML).",
        "Basic CompileReport with unit_normalization_table and term_lenses.",
        "W-space aware prox implemented with mathematical equivalence verification.",
        "Lens probe integration present but rudimentary."
      ],
      "gaps": [
        "Unit normalization is heuristic only - design requires RMS/MAD normalization per term.",
        "Lens selection not implemented - compiler sets 'lens_name' to 'identity' by default.",
        "CompileReport missing invariants_present, frame_type, and per-term normalization metadata.",
        "No pydantic validation - design requires strict Python DSL validation."
      ],
      "priority": "high",
      "recommended_next_steps": [
        "Implement per-term unit normalization (RMS/MAD) and record in CompileReport.",
        "Implement lens selection logic with lens probe integration.",
        "Add pydantic validation for EnergySpec and TermSpec.",
        "Complete CompileReport with all required metadata fields."
      ],
      "design_pattern_notes": [
        "Compiler core is Functional Core: pure functions transforming specs to JAX functions.",
        "Spec validation and error handling are Imperative Shell: side effects for user feedback."
      ],
      "tdd_notes": [
        "Compiler built with TDD: comprehensive contract tests for compilation correctness.",
        "Tests verify mathematical properties: energy computation, gradient accuracy, JIT compilation.",
        "Unit normalization and lens selection require TDD: write failing tests for RMS/MAD computation and lens probe integration."
      ]
    },
    {
      "id": "architecture_overview",
      "spec": "Shim Build Architecture: Python DSL specs, JAX-only runtime, PyArrow/DuckDB boundaries, global dtype enforcement, readiness checklist",
      "status": "partial-implemented",
      "implemented_in": [
        "src/computable_flows_shim/energy/specs.py",
        "src/computable_flows_shim/runtime/engine.py",
        "src/computable_flows_shim/telemetry/duckdb_manager.py",
        "pyproject.toml",
        "qa_logs/20251020_initial_spec_definition.md"
      ],
      "notes": [
        "Python DSL implemented as dataclasses in energy/specs.py (no YAML).",
        "Runtime boundaries enforced: JAX-only inside flow, PyArrow/DuckDB at boundaries.",
        "Global dtype enforcement partially implemented - JAX arrays used but no explicit dtype propagation policy.",
        "Readiness checklist exists but not systematically enforced."
      ],
      "gaps": [
        "Global dtype enforcement not fully implemented - design requires explicit dtype declaration and propagation everywhere.",
        "Readiness checklist not enforced - missing systematic checks for required components before flow execution.",
        "PyArrow/DuckDB integration exists but schema validation and manifest writing incomplete."
      ],
      "priority": "medium",
      "recommended_next_steps": [
        "Implement global dtype enforcement with explicit dtype fields in specs and runtime casting.",
        "Add readiness checklist enforcement in engine before flow execution.",
        "Complete PyArrow schema validation and manifest.toml writing."
      ],
      "design_pattern_notes": [
        "Python DSL specs are Functional Core: pure data structures.",
        "Runtime boundaries and dtype enforcement are Imperative Shell: side effects for validation and casting."
      ],
      "tdd_notes": [
        "Architecture components require TDD: write failing tests for dtype consistency and readiness checklist enforcement.",
        "Boundary enforcement needs TDD: contract tests for JAX-only runtime and PyArrow/DuckDB schema validation."
      ]
    },
    {
      "id": "fda_certificates",
      "spec": "Estimate eta_dd (diagonal dominance), gamma (spectral gap), Lyapunov checks, Lanczos/Gershgorin methods in W-space",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/fda/certificates.py",
        "src/computable_flows_shim/runtime/engine.py",
        "qa_logs/20251022_lanczos_spectral_gap_fixes.md"
      ],
      "notes": [
        "Functions estimate_eta_dd and estimate_gamma_lanczos fully implemented with JAX lax.scan for matrix-free operations.",
        "Lanczos algorithm hardened with spurious eigenvalue filtering, JIT compatibility, and proper spectral gap detection for both positive and negative eigenvalues.",
        "Engine calls certificate estimators at run start and logs results when telemetry_manager provided.",
        "W-space awareness implemented via TransformOp integration in estimate_gamma_lanczos.",
        "All certificate functions are JIT-compatible and type-safe."
      ],
      "gaps": [
        "Lyapunov descent checks not implemented.",
        "General LW_apply for frame-aware operator application missing.",
        "Manifold-aware core operator selection not implemented.",
        "KKT/duality gap and holdout checks missing.",
        "Spec hooks (invariants, LensPolicy, CertificationProfile) not implemented.",
        "Comprehensive telemetry integration incomplete."
      ],
      "priority": "medium",
      "recommended_next_steps": [
        "Add automated certificate policies in runtime/controller for auto-remediation (reduce step sizes, adjust lambda candidates).",
        "Integrate certificate checks with Flight Controller RED/AMBER/GREEN phase transitions.",
        "Add tolerance parameters and fallback strategies for certificate estimation failures."
      ],
      "design_pattern_notes": [
        "Certificate estimators are Functional Core: pure mathematical functions computing convergence guarantees.",
        "Certificate logging and policy decisions are Imperative Shell: side effects for telemetry and control flow."
      ],
      "tdd_notes": [
        "Certificate functions built with strict TDD: comprehensive contract tests for mathematical properties and JIT compatibility.",
        "Integration with controller phases requires TDD: write failing tests for RED/AMBER/GREEN state machine with certificate gating.",
        "Certificate policy automation needs TDD: contract tests for auto-remediation workflows."
      ]
    },
    {
      "id": "runtime_engine",
      "spec": "Run compiled flow with primitives, FDA hooks, tuner integration, telemetry (Flight Recorder), checkpoints and resume",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/runtime/engine.py",
        "src/computable_flows_shim/controller.py",
        "src/computable_flows_shim/telemetry/flight_recorder.py",
        "src/computable_flows_shim/telemetry/duckdb_manager.py",
        "src/computable_flows_shim/runtime/checkpoint.py",
        "tests/test_runtime.py",
        "tests/test_controller.py"
      ],
      "notes": [
        "FlightController implements RED/AMBER/GREEN phase machine with rollback capability and certificate-gated tuning.",
        "Basic run_flow_step and resume_flow exist with primitive composition (F_Dis → F_Proj).",
        "CheckpointManager provides atomic saves and resume with JAX array serialization.",
        "TelemetryManager and FlightRecorder integrated with Parquet/DuckDB output.",
        "Controller phases tested with certificate validation, step remediation, and budget enforcement.",
        "Missing FlowPolicy/MultiscaleSchedule integration - spec requires policy-driven flow execution.",
        "Missing global dtype enforcement - no explicit dtype propagation or casting policies.",
        "Missing formal gate conditions for phase transitions beyond basic certificate checks."
      ],
      "gaps": [
        "FlowPolicy and MultiscaleSchedule specs not implemented - runtime lacks policy-driven execution.",
        "Global dtype enforcement not implemented - no explicit dtype fields or propagation.",
        "Flight Recorder schema incomplete - missing full Parquet schema validation and manifest writing.",
        "Resume semantics incomplete - missing deterministic RNG/tuner state restoration tests."
      ],
      "priority": "high",
      "design_pattern_notes": [
        "Primitives and flow logic are Functional Core: pure computational steps.",
        "Engine orchestration, telemetry logging, and checkpointing are Imperative Shell: side effects for monitoring and persistence.",
        "Controller phase machine spans both: pure state transitions (Core) with logging side effects (Shell)."
      ],
      "tdd_notes": [
        "Controller phases built with TDD: comprehensive tests for RED/AMBER/GREEN state machine and certificate gating.",
        "Runtime engine has basic tests but missing policy integration and dtype enforcement tests.",
        "Resume functionality requires TDD: write failing tests for deterministic state restoration."
      ],
      "recommended_next_steps": [
        "Implement FlowPolicy and MultiscaleSchedule as Python DSL dataclasses.",
        "Add global dtype enforcement with explicit dtype fields in specs and runtime casting.",
        "Complete Flight Recorder schema validation and manifest.toml writing.",
        "Add end-to-end resume tests ensuring deterministic restore of RNG, tuner state, and phase."
      ]
    },
    {
      "id": "telemetry_and_io",
      "spec": "Flight Recorder: manifest, telemetry.parquet, events.parquet, DuckDB integration, privacy flags",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/telemetry/telemetry_manager.py",
        "src/computable_flows_shim/telemetry/flight_recorder.py",
        "src/computable_flows_shim/telemetry/duckdb_manager.py",
        "src/computable_flows_shim/telemetry/manifest_writer.py",
        "tests/test_flight_recorder.py"
      ],
      "notes": [
        "TelemetryManager orchestrates run directories and FlightRecorder creation.",
        "FlightRecorder writes Parquet files with atomic operations and schema metadata.",
        "DuckDBManager consolidates telemetry across runs with query capabilities.",
        "Manifest writer exists but basic - supports TOML format with fallback serializer.",
        "Flight Recorder tested with core telemetry fields and Parquet validation.",
        "Missing full schema validation against spec requirements.",
        "Missing privacy/redaction flags implementation.",
        "Manifest writing incomplete - missing dtype recording and schema version enforcement."
      ],
      "gaps": [
        "Manifest.toml incomplete - missing schema_version, dtype recording, and full metadata fields.",
        "Privacy flags not implemented - no redaction or privacy controls.",
        "Parquet schema validation missing - no enforcement of required fields and types.",
        "DuckDB integration tested but missing comprehensive query validation and cross-run analysis."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "Telemetry is Imperative Shell: all operations involve side effects (file I/O, database writes, logging).",
        "Flight Recorder data structures could be Functional Core, but I/O operations are inherently imperative."
      ],
      "tdd_notes": [
        "Flight Recorder has basic tests but requires TDD for schema validation and manifest correctness.",
        "DuckDB integration needs TDD: contract tests for query correctness and cross-run consolidation.",
        "Privacy flags require TDD: write failing tests for redaction behavior and data protection."
      ],
      "recommended_next_steps": [
        "Complete manifest.toml writer with schema_version, dtype recording, and all required metadata.",
        "Implement privacy flags and redaction controls for sensitive telemetry data.",
        "Add Parquet schema validation against spec requirements.",
        "Write comprehensive DuckDB integration tests for cross-run analysis and query correctness."
      ]
    },
    {
      "id": "multiscale_module",
      "spec": "Wavelet/transform registry, lens probe, frame-aware transforms, W-space prox, lens selection",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/multi/transform_op.py",
        "src/computable_flows_shim/multi/lens_probe.py",
        "src/computable_flows_shim/atoms/library.py",
        "src/computable_flows_shim/energy/compile.py",
        "tests/test_transform_op.py",
        "tests/test_lens_probe.py",
        "qa_logs/20251020_multiscale_primitive_completion.md",
        "qa_logs/20251020_multiscale_flow.md",
        "qa_logs/20251022_lens_probe_implementation.md"
      ],
      "notes": [
        "TransformOp class implemented with jaxwt integration and frame-aware metadata.",
        "Lens probe implemented with compressibility metrics, reconstruction error analysis, and automatic lens selection.",
        "Builder mode integration present but rudimentary - probe execution works but results integration incomplete.",
        "Basic wavelet transforms (Haar, Daubechies) supported for 1D/2D.",
        "Frame metadata correctly set (unitary vs tight frames).",
        "Compiler integration exists but lens selection defaults to 'identity'."
      ],
      "gaps": [
        "LW_apply for frame-aware operator application not implemented.",
        "LensPolicy and MultiscaleSchedule specs not implemented.",
        "Builder mode integration incomplete - lens probe exists but not fully integrated.",
        "Validation & manifest recording missing (forward/inverse consistency checks, tight-frame energy validation).",
        "Telemetry & controller integration incomplete.",
        "Graph wavelets and chirplets not implemented."
      ],
      "priority": "high",
      "recommended_next_steps": [
        "Implement LW_apply for frame-aware operator application in W-space.",
        "Implement LensPolicy and MultiscaleSchedule specs as Python DSL dataclasses.",
        "Complete builder mode integration with full lens probe execution and CompileReport recording.",
        "Add validation & manifest recording (forward/inverse consistency, tight-frame energy checks).",
        "Complete telemetry & controller integration with phase transitions and event logging.",
        "Implement graph wavelets and chirplets with proper frame constants."
      ],
      "design_pattern_notes": [
        "TransformOp and wavelet transforms are Functional Core: pure mathematical operations.",
        "Transform registry and lens probe are Imperative Shell: discovery, caching, and I/O for probe results."
      ],
      "tdd_notes": [
        "TransformOp requires strict TDD: write failing contract tests for jaxwt integration, round-trip accuracy, and frame metadata.",
        "Lens probe needs TDD: contract tests for compressibility metrics and reconstruction error calculations.",
        "W-space prox plumbing requires TDD: tests for analysis/synthesis mapping correctness."
      ]
    },
    {
      "id": "spec_validation_and_dtypes",
      "spec": "Strict Python DSL validation (pydantic), global dtype enforcement, unit tests for dtype consistency",
      "status": "partial",
      "implemented_in": [
        "src/computable_flows_shim/energy/specs.py",
        "pyproject.toml (pythonpath adjustments)"
      ],
      "notes": [
        "Energy specs exist as dataclasses; no pydantic validation layer yet.",
        "Code and tests use JAX arrays but global dtype enforcement and propagation not fully enforced.",
        "CompileReport stores unit_normalization_table but values are heuristic."
      ],
      "gaps": [
        "Add pydantic-based spec validation or stricter dataclass validators to ensure required fields and dtype declarations.",
        "Enforce and test global dtype propagation across compiler and runtime; add helper to cast inputs and manifest dtype."
      ],
      "priority": "medium",
      "recommended_next_steps": [
        "Introduce pydantic (or attrs) validators for EnergySpec and TermSpec; include dtype field.",
        "Add runtime dtype checks and automatic casting utilities; emit warnings/errors on mismatches."
      ],
      "design_pattern_notes": [
        "Spec validation is Imperative Shell: error handling and user feedback side effects.",
        "Dtype enforcement could be Functional Core (pure casting functions) or Imperative Shell (runtime checks)."
      ],
      "tdd_notes": [
        "Spec validation requires TDD: write failing tests for pydantic validation, then implement validators.",
        "Dtype consistency needs TDD: contract tests for automatic casting and mismatch detection."
      ]
    },
    {
      "id": "tuner_and_gap_dial",
      "spec": "Gap Dial tuner: automated lambda/alpha sweeps with rollback, commit gating by certificates",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/tuner/gap_dial.py (exists but not integrated)"
      ],
      "notes": [
        "GapDialTuner class implemented with basic spectral gap monitoring and adaptation logic.",
        "Simple parameter adaptation based on gap error exists.",
        "Factory function create_gap_dial_tuner() available.",
        "Basic telemetry integration present but incomplete."
      ],
      "gaps": [
        "Feasibility gates (η_dd ≤ η_max, γ ≥ γ_min) not implemented.",
        "Per-trial move caps and rollback semantics missing.",
        "GapDial policy parameters incomplete (missing beta_estimator, per_scale_seed, lambda_move_cap).",
        "Feasibility sweep algorithm not implemented.",
        "Frame-aware tuning (adjust prox thresholds by frame constant c) missing.",
        "Per-scale λ_j policies with ratio limits not implemented.",
        "Full telemetry integration incomplete."
      ],
      "priority": "medium",
      "recommended_next_steps": [
        "Implement feasibility gates with η_dd and γ certificate checks.",
        "Add per-trial move caps and rollback semantics with last-good checkpoint logic.",
        "Complete GapDial policy parameters (beta_estimator, per_scale_seed, lambda_move_cap).",
        "Implement feasibility sweep algorithm with certificate validation.",
        "Add frame-aware tuning with prox threshold adjustments by frame constant c.",
        "Implement per-scale λ_j policies with ratio limits between adjacent scales.",
        "Complete telemetry integration with full event logging."
      ],
      "design_pattern_notes": [
        "Tuner algorithms are Functional Core: pure optimization logic for parameter sweeps.",
        "Tuner state management and rollback logic are Imperative Shell: side effects for persistence and control flow."
      ],
      "tdd_notes": [
        "Tuner integration requires TDD: write failing tests for commit/rollback workflows and certificate gating.",
        "GapDial parameter sweeps need TDD: contract tests for safe trial runs and deterministic rollback."
      ]
    },
    {
      "id": "checkpoints_and_resume",
      "spec": "Atomic checkpoints, last-good-GREEN checkpoint, deterministic resume with RNG and tuner state",
      "status": "partial",
      "implemented_in": [
        "src/computable_flows_shim/runtime/engine.py (checkpoint calls)",
        "src/computable_flows_shim/serialization/ (exists)"
      ],
      "notes": [
        "Engine references CheckpointManager and uses checkpoint creation/loading calls; serialization folder exists but full resume semantics need tests.",
        "Manifest writing and atomic file operations need to be validated on Windows (rename semantics)."
      ],
      "gaps": [
        "Implement last-good-GREEN checkpoint logic and automatic rollback; add tests that simulate tuner-regression and verify rollback behavior.",
        "Ensure resume restores RNG keys, tuner state, and phase counter deterministically."
      ],
      "priority": "medium",
      "recommended_next_steps": [
        "Add 'last_good_green' checkpoint marker and test rollback path; integrate with telemetry events and manifest update.",
        "Add resume integration tests asserting exact float equality (where expected) given deterministic seeds."
      ],
      "design_pattern_notes": [
        "Checkpoint/resume logic is Imperative Shell: all operations involve file I/O and state persistence.",
        "RNG and state restoration could have Functional Core components for deterministic state transitions."
      ],
      "tdd_notes": [
        "Checkpoint semantics require TDD: write failing tests for last-good-GREEN logic and rollback behavior.",
        "Resume determinism needs TDD: contract tests for exact state restoration including RNG keys and phase counters."
      ]
    },
    {
      "id": "testing_ci_examples",
      "spec": "pytest with certificate validation, ruff linting, GitHub Actions CI, examples with end-to-end flows, cross-cutting testing ideas",
      "status": "partial-improved",
      "implemented_in": [
        "tests/test_*.py",
        "pyproject.toml",
        ".github/workflows/ci.yml",
        "README.md",
        "qa_logs/20251020_cli_runner.md"
      ],
      "notes": [
        "pytest configured with markers, JUnit XML output, and comprehensive test discovery.",
        "GitHub Actions CI workflow exists with quick test lane and artifact upload.",
        "Controller, runtime, flight recorder, and tuner tests implemented with certificate validation.",
        "Basic CLI runner exists for end-to-end flow execution.",
        "Missing ruff linting integration and certificate validation in test suite.",
        "Missing comprehensive examples with end-to-end flows.",
        "Cross-cutting testing ideas partially implemented but need expansion."
      ],
      "gaps": [
        "Ruff linting not integrated into CI or local development workflow.",
        "Certificate validation tests incomplete - missing systematic FDA compliance testing.",
        "Examples missing - no end-to-end flow examples demonstrating full capabilities.",
        "Cross-cutting testing incomplete - missing dtype consistency, boundary enforcement, and integration tests.",
        "CI workflow basic - missing comprehensive test lanes and quality gates."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "Test suites are Imperative Shell: all tests involve setup, execution, and assertion side effects.",
        "Tested code follows Functional Core pattern: pure functions tested in isolation."
      ],
      "tdd_notes": [
        "Existing tests built with TDD: controller phases, runtime engine, and telemetry have comprehensive contract tests.",
        "Missing TDD for cross-cutting concerns: write failing tests for dtype consistency and boundary enforcement.",
        "Certificate validation requires TDD: systematic FDA compliance testing with mathematical property verification."
      ],
      "recommended_next_steps": [
        "Integrate ruff linting into CI workflow and development setup.",
        "Add systematic certificate validation tests for all FDA compliance requirements.",
        "Create comprehensive examples demonstrating end-to-end flows with all primitives.",
        "Implement cross-cutting testing for dtype consistency, JAX-only boundaries, and integration scenarios.",
        "Expand CI workflow with comprehensive test lanes and quality gates."
      ]
    },
    {
      "id": "extensibility_backends",
      "spec": "Op/prox registries with Python entry points, transform/manifold registries, backend adapters (JAX/Torch), plugin system for ops without modifying core",
      "status": "partial-1of4",
      "implemented_in": [
        "src/computable_flows_shim/atoms/registry.py",
        "src/computable_flows_shim/atoms/base.py"
      ],
      "notes": [
        "Atoms registry system implemented with register_atom/get_atom_class for dynamic discovery.",
        "Abstract Atom base class with proper interface contracts.",
        "Only atoms registry implemented - missing ops, transforms, manifolds, and backends registries.",
        "No Python entry points defined in pyproject.toml.",
        "No backend adapters implemented (JAX assumed, no Torch backend).",
        "Plugin system exists for atoms but not extensible to other components."
      ],
      "gaps": [
        "Ops registry not implemented - no Op class protocol or registry system.",
        "Transform registry not implemented - no TransformOp registry or entry points.",
        "Manifold registry not implemented - no manifold adapters or registry.",
        "Backend adapters not implemented - no backend abstraction layer.",
        "Python entry points not configured - no plugin system for external contributions.",
        "Registry path constants not defined for consistency."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "Registries are Imperative Shell: handle component discovery and instantiation side effects.",
        "Backend adapters follow ports-and-adapters: stable interfaces with implementation-specific wrappers."
      ],
      "tdd_notes": [
        "Registry systems require TDD: write failing tests for entry point discovery and plugin loading.",
        "Backend adapters need TDD: contract tests for backend interchangeability and API compliance."
      ],
      "recommended_next_steps": [
        "Implement Op class protocol and ops registry with entry points.",
        "Create transform and manifold registries following atoms pattern.",
        "Add backend adapter abstraction layer for JAX/Torch interchangeability.",
        "Configure Python entry points in pyproject.toml for plugin system.",
        "Define registry path constants file for consistent entry point names."
      ]
    },
    {
      "id": "naming_and_layout",
      "spec": "Canonical file/module names, ports-and-adapters layout, registry paths, CLI entry points, dtype policy, examples as Python DSL",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/",
        "src/computable_flows_shim/cli/run.py",
        "pyproject.toml",
        "README.md"
      ],
      "notes": [
        "Module layout follows spec: api.py, controller.py, runtime/, energy/, multi/, fda/, atoms/, telemetry/.",
        "CLI entry points not registered in pyproject.toml - manual script execution only.",
        "Ports-and-adapters partially implemented: multi/ contains adapters, but no backends/ directory.",
        "Registry path constants not defined - hardcoded registry usage.",
        "Dtype policy partially implemented - JAX arrays used but no global dtype enforcement.",
        "Examples exist as Python code but not comprehensive end-to-end flows."
      ],
      "gaps": [
        "CLI entry points not registered - no cf-run, cf-hud commands available.",
        "Registry path constants file missing - inconsistent entry point naming.",
        "Backends directory not implemented - no backend adapter separation.",
        "Global dtype helpers missing - no get_global_dtype/set_global_dtype functions.",
        "Examples incomplete - missing comprehensive Python DSL examples.",
        "File naming mostly follows spec but some inconsistencies remain."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "Module layout follows Functional Core/Imperative Shell: core algorithms separate from I/O.",
        "Ports-and-adapters maximizes backend substitution without code drift."
      ],
      "tdd_notes": [
        "Layout conventions require TDD: write failing tests for import structure and module boundaries.",
        "CLI entry points need TDD: contract tests for command-line interface compliance."
      ],
      "recommended_next_steps": [
        "Register CLI entry points in pyproject.toml (cf-run, cf-hud, cf-cert, cf-viz).",
        "Create registry_paths.py with canonical entry point constants.",
        "Implement backends/ directory with JAX backend adapter.",
        "Add global dtype API functions in api.py.",
        "Create comprehensive examples/ directory with Python DSL specs.",
        "Audit and fix any remaining file naming inconsistencies."
      ]
    },
    {
      "id": "fda_hooks",
      "spec": "StateSpec invariants, LensPolicy, FlowPolicy, GapDial, MultiscaleSchedule, SparsityPolicy, CertificationProfile, compile report fields, telemetry columns",
      "status": "partial-2of9",
      "implemented_in": [
        "src/computable_flows_shim/energy/compile.py",
        "src/computable_flows_shim/energy/specs.py",
        "src/computable_flows_shim/multi/lens_probe.py"
      ],
      "notes": [
        "CompileReport partially implemented with lens_name, unit_normalization_table, term_lenses.",
        "Lens probe integration exists but basic - no LensPolicy spec or formal selection rules.",
        "StateSpec basic - no invariants field or validation.",
        "No FlowPolicy, GapDial, MultiscaleSchedule, SparsityPolicy, or CertificationProfile specs.",
        "Telemetry schema incomplete - missing invariant_drift_max, phi_residual, lens_name, etc.",
        "Controller extensible but missing formal FDA hook integration."
      ],
      "gaps": [
        "StateSpec.invariants not implemented - no conserved/constraints/symmetries validation.",
        "LensPolicy spec missing - no candidate transforms or probe metrics specification.",
        "FlowPolicy spec missing - no family/discretization/preconditioner selection.",
        "GapDial spec missing - no eta_max/gamma_min/beta_estimator parameters.",
        "MultiscaleSchedule spec missing - no residual_driven/level activation logic.",
        "SparsityPolicy spec missing - no penalty/thresholding/adaptive_rule configuration.",
        "CertificationProfile spec missing - no systematic check configuration.",
        "CompileReport incomplete - missing frame_type/c, invariants_present flag.",
        "Telemetry schema missing FDA-specific columns and events."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "FDA hooks are Imperative Shell: validation, logging, and control flow side effects.",
        "Spec dataclasses are Functional Core: pure data structures for configuration."
      ],
      "tdd_notes": [
        "FDA hooks require TDD: write failing tests for invariant validation and policy enforcement.",
        "Spec validation needs TDD: contract tests for dataclass field validation and type safety."
      ],
      "recommended_next_steps": [
        "Add invariants field to StateSpec with validation hooks in controller.",
        "Implement LensPolicy, FlowPolicy, GapDial, MultiscaleSchedule, SparsityPolicy specs.",
        "Add CertificationProfile with systematic check configuration.",
        "Complete CompileReport with all required metadata fields.",
        "Extend telemetry schema with FDA-specific columns and events.",
        "Integrate FDA hooks into controller phase transitions and builder mode."
      ]
    },
    {
      "id": "pareto_knob_surface",
      "spec": "Pareto Manager for multi-objective experiments: register objectives/constraints, generate candidates, evaluate with certified sweeps, compute Pareto front",
      "status": "not-implemented",
      "implemented_in": [],
      "notes": [
        "No Pareto Manager implementation exists.",
        "No multi-objective experiment orchestration.",
        "No certified sweeps with RED/AMBER/GREEN gates for Pareto evaluation.",
        "No Pareto front computation or sidecar telemetry storage."
      ],
      "gaps": [
        "ParetoManager class not implemented - no API for registering objectives/constraints.",
        "Candidate generation not implemented - no weighted-sum, ε-constraint, or reference-point methods.",
        "Certified evaluation not implemented - no integration with controller.run_certified.",
        "Pareto front computation missing - no non-dominated set calculation.",
        "Pareto sidecar telemetry missing - no trials.parquet, front.parquet, or policy.json.",
        "CLI commands missing - no 'cf pareto' commands or notebook UX."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "Pareto Manager would be Imperative Shell: orchestrates experiments and collects results.",
        "Pareto front computation could be Functional Core: pure mathematical operations on objective data."
      ],
      "tdd_notes": [
        "Pareto Manager requires TDD: write failing tests for multi-objective orchestration and front computation.",
        "Certified sweeps need TDD: contract tests for RED/AMBER/GREEN gate integration."
      ],
      "recommended_next_steps": [
        "Implement ParetoManager class with objectives/constraints registration API.",
        "Add candidate generation methods (weighted-sum, ε-constraint, reference-point).",
        "Integrate with controller.run_certified for safe multi-objective evaluation.",
        "Implement Pareto front computation and sidecar telemetry storage.",
        "Add CLI commands and notebook examples for Pareto experiments."
      ]
    },
    {
      "id": "tensor_logic_frontend",
      "spec": "Tensor Logic front-end: TTensor/TOp/TObjective IR, translation to EnergySpec, optional adapter for mathematicians",
      "status": "not-implemented",
      "implemented_in": [],
      "notes": [
        "No Tensor Logic IR implementation exists.",
        "No translation from tensor programs to EnergySpec.",
        "No declarative tensor-equation input support.",
        "Core Shim unchanged as designed (optional adapter)."
      ],
      "gaps": [
        "TTensor/TOp/TObjective/TProgram dataclasses not implemented.",
        "Translation logic missing - no mapping from tensor ops to EnergySpec.",
        "No support for einsum/matmul/add/reshape/concat/select/project ops.",
        "No objective translation (lsq, cross_entropy, kl, l1, tv, indicator).",
        "No front-end compilation or runtime integration.",
        "No telemetry tagging with front-end objective names."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "Tensor Logic IR is Functional Core: pure data structures for tensor programs.",
        "Translation logic is Functional Core: pure transformation from tensor IR to EnergySpec.",
        "Runtime integration is Imperative Shell: telemetry tagging and execution orchestration."
      ],
      "tdd_notes": [
        "Tensor Logic requires TDD: write failing tests for IR parsing and EnergySpec translation.",
        "Translation correctness needs TDD: contract tests for mathematical equivalence."
      ],
      "recommended_next_steps": [
        "Implement TTensor/TOp/TObjective/TProgram dataclasses for tensor program IR.",
        "Add translation logic from tensor ops/objectives to EnergySpec format.",
        "Support core tensor operations (einsum, matmul, add, reshape, etc.).",
        "Implement objective translation (lsq, l1, tv, etc.) to f/g functions.",
        "Add front-end compilation and runtime integration with telemetry tagging."
      ]
    },
    {
      "id": "contributor_guide",
      "spec": "Branch/commit naming, ruff/mypy enforcement, test matrix, JAX-only runtime policy, IO stack recommendations, release process",
      "status": "partial-1of6",
      "implemented_in": [
        "pyproject.toml",
        ".github/workflows/ci.yml",
        "README.md"
      ],
      "notes": [
        "Basic pytest configuration exists with markers and JUnit output.",
        "GitHub Actions CI workflow exists but only runs pytest.",
        "README has basic setup instructions.",
        "No ruff/mypy configuration or enforcement.",
        "No branch/commit naming conventions documented or enforced.",
        "JAX-only runtime policy not enforced - no linting rules for forbidden imports."
      ],
      "gaps": [
        "Ruff linting not configured or integrated into CI/development workflow.",
        "Mypy type checking not configured.",
        "Branch/commit naming conventions not documented or enforced.",
        "Test matrix incomplete - no CUDA testing or comprehensive test lanes.",
        "JAX-only runtime policy not enforced - no linting rules preventing numpy/scipy imports in runtime modules.",
        "IO stack recommendations not documented - no guidance on PyArrow/DuckDB/Pandas usage.",
        "Release process not documented - no version bumping or environment.lock procedures."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "Contributor tooling is Imperative Shell: enforces development workflow and quality gates.",
        "JAX-only policy enforcement could be Functional Core (static analysis) or Imperative Shell (runtime checks)."
      ],
      "tdd_notes": [
        "Contributor tooling requires TDD: write failing tests for linting/type checking integration.",
        "Policy enforcement needs TDD: contract tests for JAX-only runtime compliance."
      ],
      "recommended_next_steps": [
        "Configure ruff linting and mypy type checking in pyproject.toml.",
        "Integrate ruff and mypy into CI workflow and development setup.",
        "Document and enforce branch/commit naming conventions.",
        "Expand test matrix with CUDA testing and comprehensive test lanes.",
        "Add JAX-only runtime policy enforcement with import restrictions.",
        "Document IO stack recommendations and version pinning procedures.",
        "Document release process with version bumping and environment locking."
      ]
    },
    {
      "id": "telemetry_schema",
      "spec": "Telemetry & Events Schema: schema_version 3, telemetry.parquet columns (run_id, phase, iter, trial_id, t_wall_ms, alpha, lambda, lambda_j, E, grad_norm, eta_dd, gamma, sparsity_wx, metric_ber, warnings, notes, invariant_drift_max, phi_residual, lens_name, level_active_max, sparsity_mode, flow_family), events.parquet columns (run_id, t_wall_ms, event, payload), events enum (SPEC_LINT_FAIL, CERT_FAIL, CERT_PASS, TUNER_MOVE_REJECTED, ROLLBACK, TIMEOUT, CANCELLED, RUN_STARTED, RUN_FINISHED, LENS_SELECTED, SCALE_ACTIVATED), versioning & compatibility",
      "status": "partial-improved",
      "implemented_in": [
        "src/computable_flows_shim/telemetry/flight_recorder.py",
        "src/computable_flows_shim/telemetry/manifest_writer.py",
        "src/computable_flows_shim/controller.py",
        "src/computable_flows_shim/runtime/engine.py",
        "tests/test_flight_recorder.py"
      ],
      "notes": [
        "Schema version 3 hardcoded in FlightRecorder and included in manifest.toml and Parquet metadata.",
        "Most telemetry columns implemented: run_id, phase, iter, trial_id, t_wall_ms, alpha, lambda, E, grad_norm, eta_dd, gamma, sparsity_wx, warnings, notes.",
        "Some columns have placeholder values: phi_residual (NaN), invariant_drift_max (NaN).",
        "Events system implemented with run_id, t_wall_ms, event, payload columns.",
        "Many events implemented: RUN_STARTED, RUN_FINISHED, ROLLBACK, PHASE_TRANSITION, CERT_CHECK, CERT_REMEDIATION, GAP_DIAL_ENABLED, BUDGET_EXCEEDED, STEP_REMEDIATION, STEP_FAIL, FLOW_RESUMED, CHECKPOINT_CREATED, RUN_FAILED, TUNING_FAILED.",
        "Flight Recorder tested with atomic writes and schema validation."
      ],
      "gaps": [
        "lambda_j stored as string but spec requires JSON string format for cross-language compatibility.",
        "Missing spec-required telemetry columns: metric_ber, lens_name, level_active_max, sparsity_mode, flow_family.",
        "Missing spec-required events: SPEC_LINT_FAIL, CERT_FAIL, CERT_PASS, TUNER_MOVE_REJECTED, TIMEOUT, CANCELLED, LENS_SELECTED, SCALE_ACTIVATED.",
        "invariant_drift_max and phi_residual are placeholders - need actual invariant drift and physics residual computation.",
        "Schema validation incomplete - no enforcement of required fields and types against spec."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "Flight Recorder data structures are Imperative Shell: I/O operations and side effects.",
        "Schema definitions could be Functional Core: pure data structure specifications."
      ],
      "tdd_notes": [
        "Telemetry schema requires TDD: write failing tests for schema validation and required field enforcement.",
        "Event logging needs TDD: contract tests for event enum compliance and payload validation."
      ],
      "recommended_next_steps": [
        "Implement lambda_j as proper JSON string format for per-scale λ_j storage.",
        "Add missing telemetry columns: metric_ber, lens_name, level_active_max, sparsity_mode, flow_family.",
        "Implement missing events: SPEC_LINT_FAIL, CERT_FAIL, CERT_PASS, TUNER_MOVE_REJECTED, TIMEOUT, CANCELLED, LENS_SELECTED, SCALE_ACTIVATED.",
        "Compute actual invariant_drift_max and phi_residual values instead of placeholders.",
        "Add schema validation against spec requirements in FlightRecorder."
      ]
    },
    {
      "id": "ci_and_environment",
      "spec": "CI & Environment Setup: Python 3.10/3.11, virtual env, dev dependencies (pytest, ruff, black, isort, mypy, pre-commit), pyproject.toml PEP621, environment.lock files, manual JAX install, GitHub Actions CI (lint, test, readiness), pre-commit hooks, readiness_check.sh, schema_validate.py, Dockerfile, VS Code setup",
      "status": "partial-1of7",
      "implemented_in": [
        "pyproject.toml",
        ".github/workflows/ci.yml",
        "requirements.txt",
        "README.md"
      ],
      "notes": [
        "Python environment setup documented in README but no specific version enforcement.",
        "pyproject.toml configured with pytest, markers, JUnit output, and test discovery.",
        "GitHub Actions CI workflow exists with quick test lane and artifact upload.",
        "JAX install documented as manual step in design spec.",
        "Basic environment setup exists but missing most tooling."
      ],
      "gaps": [
        "Dev dependencies incomplete - missing ruff, black, isort, mypy, pre-commit in requirements or pyproject.toml.",
        "CI pipeline basic - missing lint step, readiness check, and schema validation.",
        "Pre-commit hooks not configured (.pre-commit-config.yaml missing).",
        "Readiness check script (scripts/readiness_check.sh) not implemented.",
        "Schema validation script (scripts/schema_validate.py) not implemented.",
        "Environment lock files (environment.lock, environment.cuda.lock) not implemented.",
        "Dockerfile not implemented.",
        "VS Code workspace settings incomplete - missing linting, formatting, test discovery configuration."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "CI/CD tooling is Imperative Shell: enforces development workflow and quality gates.",
        "Environment setup scripts are Imperative Shell: side effects for dependency installation and validation."
      ],
      "tdd_notes": [
        "CI tooling requires TDD: write failing tests for readiness check and schema validation scripts.",
        "Environment setup needs TDD: contract tests for dependency resolution and lock file generation."
      ],
      "recommended_next_steps": [
        "Add dev dependencies (ruff, black, isort, mypy, pre-commit) to pyproject.toml or requirements-dev.txt.",
        "Expand CI pipeline with lint, readiness check, and schema validation steps.",
        "Configure pre-commit hooks with ruff, black, isort, runtime-imports-check.",
        "Implement scripts/readiness_check.sh (runs lint, tests, schema-validate).",
        "Implement scripts/schema_validate.py for Parquet/manifest validation.",
        "Generate environment.lock and environment.cuda.lock files.",
        "Create Dockerfile with Python 3.10-slim and manual JAX install.",
        "Complete .vscode/settings.json with linting, formatting, and test discovery."
      ]
    },
    {
      "id": "atoms_library_review",
      "spec": "Atom-based API: run_certified(spec) with terms using type/op/target/weight/weight_key, tuner section with parameter ranges, direct spec-to-energy compilation",
      "status": "not-implemented",
      "implemented_in": [],
      "notes": [
        "No support for atom-based energy specification format shown in review spec.",
        "Current API (run_certified_with_telemetry) takes pre-compiled energy functions, not declarative specs with atoms.",
        "No support for weight_key references to tuner parameters.",
        "No support for tuner section with parameter ranges and log scaling.",
        "No direct spec-to-energy compilation - requires manual EnergySpec construction and compilation.",
        "Review example shows clean user API: run_certified(spec=spec, initial_state=init_state, ops=ops, data=data) but this doesn't exist."
      ],
      "gaps": [
        "Atom-based spec parser not implemented - no translation from atom specs to EnergySpec.",
        "Tuner integration not implemented - no weight_key resolution or parameter sweeping.",
        "User-facing run_certified API not implemented - current API requires compiled energy functions.",
        "Spec validation not implemented - no pydantic validation for atom-based specs."
      ],
      "priority": "high",
      "design_pattern_notes": [
        "Atom-based specs are Functional Core: pure data structures for energy specification.",
        "Spec parsing and compilation are Imperative Shell: validation, error handling, and compilation orchestration."
      ],
      "tdd_notes": [
        "Atom-based API requires TDD: write failing tests for spec parsing, weight_key resolution, and direct run_certified.",
        "Spec validation needs TDD: contract tests for atom spec format compliance."
      ],
      "recommended_next_steps": [
        "Implement atom-based spec parser to translate review format to EnergySpec.",
        "Add weight_key resolution in compilation with tuner parameter substitution.",
        "Create user-facing run_certified API that accepts atom specs directly.",
        "Add pydantic validation for atom-based energy specifications."
      ]
    },
    {
      "id": "cf_low_level_readiness_checklist",
      "spec": "16 readiness requirements: reproducibility, schema/versioning, validation, checkpointing, performance, failure modes, UX, testing, security, documentation, backward compatibility, AI-friendliness, extensibility, release process",
      "status": "partial-4of16",
      "implemented_in": [
        "src/computable_flows_shim/controller.py (budget enforcement, rollback)",
        "src/computable_flows_shim/runtime/checkpoint.py (atomic checkpoints, resume)",
        "src/computable_flows_shim/telemetry/ (schema versioning, events)",
        "tests/ (unit tests, integration tests)",
        ".github/workflows/ci.yml (basic CI)"
      ],
      "notes": [
        "Budget enforcement implemented in controller with timeout and iteration limits.",
        "Atomic checkpointing and resume implemented with JAX array serialization.",
        "Schema versioning (v3) and events system implemented in telemetry.",
        "Basic unit/integration testing implemented with pytest.",
        "Basic CI workflow exists but minimal - only runs pytest."
      ],
      "gaps": [
        "Reproducibility: no global PRNG seed management, no deterministic flag, no environment.lock files.",
        "Schema/versioning: no spec_version enforcement, no events enum registry file.",
        "Validation: no spec linter, no NaN/Inf sentry, no unit normalization (heuristic only).",
        "Checkpointing: no last-good-GREEN checkpoint logic, no deterministic RNG/tuner state restoration tests.",
        "Performance: no JIT warmup, no XLA cache persistence, no profiler hooks.",
        "Failure modes: no graceful SIGINT handling, no configurable fail-closed policy.",
        "UX: basic HUD exists but no run_card.json, no tiny HTML reports, no stable HUD columns.",
        "Testing: no certificate validation tests, no golden notebooks, no cross-cutting tests.",
        "Security: no PII scrubbing, no artifact redaction.",
        "Documentation: no cookbook examples, no troubleshooting guides.",
        "Backward compatibility: no deprecation policy, no feature flags.",
        "AI-friendliness: no stable field names enforcement, no state machine transcripts.",
        "Extensibility: no registries for ops/transforms/manifolds/backends.",
        "Release: no readiness_check.sh, no schema_validate.py, no Dockerfile, no VS Code setup."
      ],
      "priority": "high",
      "design_pattern_notes": [
        "Readiness checklist items are Imperative Shell: validation, logging, error handling, and system orchestration.",
        "Core algorithms remain Functional Core: pure mathematical operations."
      ],
      "tdd_notes": [
        "Readiness checklist requires TDD: write failing tests for each requirement, then implement systematically.",
        "Validation and guardrails need TDD: contract tests for spec linting, NaN detection, and normalization."
      ],
      "recommended_next_steps": [
        "Implement global PRNG seed management and deterministic mode flag.",
        "Add spec linter with hard errors for invalid specs and NaN/Inf sentry.",
        "Implement proper unit normalization (RMS/MAD) and last-good-GREEN checkpoints.",
        "Add graceful SIGINT handling and configurable failure policies.",
        "Create run_card.json, tiny HTML reports, and stable HUD interface.",
        "Implement readiness_check.sh and schema_validate.py scripts.",
        "Add PII scrubbing, artifact redaction, and cookbook documentation.",
        "Create Dockerfile and complete VS Code workspace configuration."
      ]
    },
    {
      "id": "telemetry_run_capsule",
      "spec": "Telemetry & Run Capsule: directory structure (telematry_cfs/fda_run_{id}/), run ID scheme (YYYYMMDD_HHMMSS), manifest.toml/events.parquet/telemetry.parquet, DuckDB consolidation, append/atomic write modes, schema_version 3, phi_residual/invariant_drift_max as core fields",
      "status": "partial-improved",
      "implemented_in": [
        "src/telematry_cfs/ (directory structure with run folders)",
        "src/computable_flows_shim/telemetry/flight_recorder.py (Parquet writing with schema metadata)",
        "src/computable_flows_shim/telemetry/manifest_writer.py (TOML manifest writing)",
        "src/computable_flows_shim/telemetry/duckdb_manager.py (DuckDB table creation)",
        "src/scripts/cfs_cli.py (append and atomic write modes)"
      ],
      "notes": [
        "Directory structure implemented with telematry_cfs/ containing fda_run_{YYYYMMDD_HHMMSS} folders.",
        "Each run folder contains manifest.toml, telemetry.parquet, and events.parquet as specified.",
        "Flight recorder writes Parquet files with atomic operations and schema metadata.",
        "DuckDB manager creates telemetry/events tables but no consolidation process implemented.",
        "CLI supports both append mode (dev/tuner) and atomic run mode (production).",
        "Schema version hardcoded to 3 in FlightRecorder but not bumped from previous version 1."
      ],
      "gaps": [
        "DuckDB database file (duckdb.db) not created at telematry_cfs/ root level.",
        "DuckDB consolidation process not implemented - no periodic scan and attach of Parquet files.",
        "Per-flow aggregation directories (flows/{flow_name}/) not implemented.",
        "Run isolation vs aggregation strategy not fully implemented.",
        "Schema version still 1 in manifests, not bumped to 3 as specified.",
        "phi_residual and invariant_drift_max logged as NaN placeholders, not computed values.",
        "lambda_j stored as string but spec requires JSON string format.",
        "Missing spec-required events: SPEC_LINT_FAIL, CERT_FAIL, CERT_PASS, TUNER_MOVE_REJECTED, TIMEOUT, CANCELLED, LENS_SELECTED, SCALE_ACTIVATED.",
        "Missing telemetry columns: metric_ber, lens_name, level_active_max, sparsity_mode, flow_family."
      ],
      "priority": "medium",
      "design_pattern_notes": [
        "Telemetry writing is Imperative Shell: I/O operations and file system side effects.",
        "Run capsule structure follows Functional Core boundaries: data persistence at JAX/PyArrow boundary."
      ],
      "tdd_notes": [
        "Telemetry capsule requires TDD: write failing tests for directory structure, atomic writes, and consolidation.",
        "DuckDB integration needs TDD: contract tests for Parquet attachment and cross-run queries."
      ],
      "recommended_next_steps": [
        "Create duckdb.db at telematry_cfs/ root and implement consolidation process.",
        "Implement per-flow aggregation directories with dev_telemetry.parquet and tuner_telemetry.parquet.",
        "Bump schema version to 3 in manifests and update schema validation.",
        "Compute actual phi_residual and invariant_drift_max values instead of NaN placeholders.",
        "Implement lambda_j as proper JSON string format for per-scale storage.",
        "Add missing telemetry columns and events as specified in schema.",
        "Implement periodic consolidation process for efficient cross-run querying."
      ]
    },
    {
      "id": "ux_flow_card",
      "spec": "Flow Card UX: Math Card (LaTeX energy formula + term chips with grad pulses) + Stability Card (health light, coupling/settling gauges, score sparkline, complexity metrics, event ticker), anime.js animations, plain language mapping, data contract with active_terms/grad_share",
      "status": "partial-1of2",
      "implemented_in": [
        "src/ux/sparsity_hud_demo.html (stability card with sparsity visualization)",
        "src/ux/package.json (anime.js dependency)",
        "src/scripts/cfs_cli.py (hud command)"
      ],
      "notes": [
        "Stability Card partially implemented with sparsity bar, sparkline, health indicator, and event ticker.",
        "Anime.js animations implemented for sparsity changes, compression waves, and particle effects.",
        "HUD command in CLI launches local HTTP server for demo.",
        "WebSocket connection framework exists for real-time telemetry streaming.",
        "Plain language used for sparsity metrics and health status."
      ],
      "gaps": [
        "Math Card not implemented - no LaTeX rendering of energy formula or term chips with gradient pulses.",
        "Missing coupling index and settling rate gauges (η_dd and γ mappings).",
        "No flow diagram showing primitive chain (descend → tidy → change view).",
        "Data contract incomplete - missing active_terms array with grad_share, lens_name, level_active_max.",
        "No run_card.json or tiny HTML reports generation.",
        "Event ticker uses demo events, not real telemetry events translated to plain language.",
        "No Pareto front visualization or side tabs (when ready).",
        "HUD not integrated with actual telemetry streaming - demo mode only."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "UX is Imperative Shell: user interaction, real-time updates, and visual feedback.",
        "Data contract follows Functional Core: pure data structures for telemetry updates."
      ],
      "tdd_notes": [
        "UX components require TDD: write failing tests for data contract compliance and animation triggers.",
        "Real-time streaming needs TDD: contract tests for WebSocket telemetry updates."
      ],
      "recommended_next_steps": [
        "Implement Math Card with LaTeX energy formula rendering and term chips with grad pulses.",
        "Add coupling index and settling rate gauges using η_dd and γ values.",
        "Create flow diagram showing active primitive chain.",
        "Complete data contract with active_terms, grad_share, and all required telemetry fields.",
        "Implement run_card.json generation and tiny HTML report creation.",
        "Connect event ticker to real telemetry events with plain language translation.",
        "Add Pareto front visualization and optional side tabs.",
        "Integrate HUD with actual telemetry streaming instead of demo mode."
      ]
    },
    {
      "id": "ux_backlog_scaffold",
      "spec": "UX Backlog Scaffold: trimmed HUD with two-card layout, plain language, single updateTelemetry() function, anime.js animations, composable cards, WebSocket streaming adapter",
      "status": "partial-improved",
      "implemented_in": [
        "src/ux/sparsity_hud_demo.html (HTML scaffold with anime.js)",
        "src/ux/package.json (development setup)",
        "src/scripts/cfs_cli.py (hud command with HTTP server)"
      ],
      "notes": [
        "HTML scaffold implemented with anime.js animations and two-card layout foundation.",
        "Plain language used throughout the interface (sparsity levels, health status).",
        "Anime.js animations implemented for gauge updates, pulses, and transitions.",
        "WebSocket framework exists for real-time telemetry connection.",
        "HTTP server setup in CLI for local development.",
        "Particle system and sound effects implemented for enhanced UX."
      ],
      "gaps": [
        "Single updateTelemetry(data) function not implemented - multiple separate update functions exist.",
        "Math Card not implemented - only Stability Card exists.",
        "Data contract not fully implemented - missing active_terms, grad_share, coupling/settling gauges.",
        "Composable cards not fully separated - tightly coupled HTML structure.",
        "WebSocket streaming adapter incomplete - demo mode only, no real telemetry integration.",
        "No adapter for existing JSON field names to HUD expectations.",
        "Missing flow diagram and term chips with gradient pulses.",
        "No Pareto front or side tab support."
      ],
      "priority": "low",
      "design_pattern_notes": [
        "HUD scaffold is Imperative Shell: DOM manipulation, animations, and user interaction.",
        "Data streaming follows Functional Core: pure data flow from telemetry to visual updates."
      ],
      "tdd_notes": [
        "HUD scaffold requires TDD: write failing tests for updateTelemetry function and data contract.",
        "WebSocket adapter needs TDD: contract tests for telemetry message parsing and UI updates."
      ],
      "recommended_next_steps": [
        "Implement single updateTelemetry(data) function that updates all HUD components.",
        "Complete Math Card implementation with LaTeX and term chips.",
        "Add missing data contract fields (active_terms, grad_share, gauges).",
        "Separate cards into composable components with clean interfaces.",
        "Complete WebSocket streaming adapter for real telemetry integration.",
        "Create adapter layer for existing telemetry JSON format to HUD expectations.",
        "Add flow diagram, Pareto front, and side tab support.",
        "Implement run_card.json generation and report creation."
      ]
    }
  ],
  "top_priority_tasks": [
    {
      "task": "Implement atom-based API from atoms_library_review spec: run_certified(spec) with weight_key tuner integration",
      "reason": "User-facing API is completely missing - atoms library exists but no way for users to specify energies using atoms as shown in review example.",
      "priority": "high"
    },
    {
      "task": "Implement cf_low_level_readiness_checklist requirements: spec linter, NaN/Inf sentry, unit normalization, last-good-GREEN checkpoints",
      "reason": "Readiness checklist is critical for production deployment - currently only 4 of 16 requirements implemented.",
      "priority": "high"
    },
    {
      "task": "Implement FDA hooks specs (StateSpec.invariants, LensPolicy, FlowPolicy, GapDial, MultiscaleSchedule, SparsityPolicy, CertificationProfile)",
      "reason": "FDA hooks are foundational to system operation and certification - required for proper Flow Dynamics Analysis integration.",
      "priority": "high"
    }
  ],
  "implementation_guidance_from_docs": {
    "jaxwt": {
      "location": "archive/jaxwt-docs/docs/jaxwt.rst",
      "summary": "jaxwt provides differentiable JAX-native wavelet forward/inverse transforms (dwt/idwt) and recommended API patterns for multiscale transforms.",
      "recommended_api": {
        "TransformOp.forward": "call jaxwt.dwt_nD(x, levels=..., wavelet=..., axes=...) returning coefficient pytree or flat array",
        "TransformOp.inverse": "call jaxwt.idwt_nD(coeffs, levels=..., wavelet=..., axes=...) to reconstruct physical-domain array",
        "frame_metadata": "expose {\"frame\": 'tight'|'unitary'|'general', \"c\": float(frame_constant), \"levels\": int}" 
      },
      "notes": [
        "Vendor or depend on 'jaxwt' in requirements (see archive/jaxwt-docs/docs/requirements.txt).",
        "Implement TransformOp so forward/inverse are pure JAX functions (no host-side Python IO) and accept/return jnp.ndarray or pytrees of arrays for multi-band outputs.",
        "Record frame constant 'c' when transform is a tight frame; compiler and FDA must use it to scale operator norms in W-space.",
        "Provide small wrapper adapters so the rest of the Shim can treat W.forward/W.inverse generically regardless of underlying library."
      ]
    },
    "jax": {
      "location": "archive/jax-docs-archive/docs",
      "summary": "JAX docs emphasize pure functions, use of jax.jit, jax.vmap, jax.lax.scan for loops, and PRNGKey splitting. Also recommend explicit dtype control and avoid Python-side loops in JITted paths.",
      "implementation_hints": [
        "Use jax.lax.scan to implement Lanczos / iterative Krylov methods so they are JIT-friendly and traceable.",
        "Use jax.vmap for batched operator application but avoid vmap over very large dims that materialize large matrices; prefer matrix-free operations and lax loops.",
        "PRNG: use jax.random.PRNGKey and jax.random.split(key) patterns; ensure RNG keys are part of checkpoint/manifest when reproducibility required.",
        "Enforce dtype by casting inputs with jnp.asarray(x, dtype=global_dtype) at compile boundaries; record dtype in manifest.toml.",
        "Prefer jax.jit(jax.grad(...)) patterns for f_grad and annotate static_argnums for non-array args when needed.",
        "For linear operator probing (L_apply), prefer matrix-free L_apply(v) that calls W.inverse/forward around the physical L_apply to avoid building dense matrices."
      ]
    }
  }
}
